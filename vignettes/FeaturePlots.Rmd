---
title: "Exploring Methylation and Accessibility Calls"
author: "Scott Furlan"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
params:
  EVAL: !r identical(Sys.getenv("NOT_CRAN"), "true")
vignette: >
  %\VignetteIndexEntry{Exploring Methylation and Accessibility Calls}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
alias: dna_fusions
editor_options: 
  chunk_output_type: console
---

```{r, child="children/SETTINGS-knitr_fusions.txt"}
```


```{r}
gff <- "/Users/sfurlan/refs/GRCh38/gencode.v49.annotation.gff3"
data <- import(gff)
can <- pbmcapply::pbmclapply(data$tag, function(vec) grep("Ensembl_canonical", vec), mc.cores = detectCores())
hits <- which(sapply(can, function(item) length(item)>0))
canonical <- data[hits,]
tss <- canonical[canonical$type=="start_codon",]
start(tss) <- start(tss) - 2000
end(tss) <- end(tss) + 2000
tss$name <- tss$gene_name

tornado_plot(bw, tss)
tornado_plot(bwm, tss)
```




```{r}
library(pacbiowdlR)
###REQUIRED FUNCTIONS


# make a matrix (regions x bins). If lengths differ, pad with NA (left-align).
as_matrix <- function(out) {
  lens <- vapply(out, function(r) length(cov_vec(r)), integer(1))
  if (length(unique(lens)) != 1L) {
    L <- max(lens)
    mat <- t(vapply(out, function(r) {
      v <- cov_vec(r)
      c(v, rep(NA_real_, L - length(v)))
    }, numeric(L)))
  } else {
    L <- lens[1]
    mat <- t(vapply(out, function(r) as.numeric(r$coverage), numeric(L)))
  }
  rownames(mat) <- vapply(out, function(r) if (!is.null(r$name)) r$name else "", character(1))
  mat
}

# pull coverage vector; gracefully handle NULL/NA
cov_vec <- function(r) {
  v <- r$coverage
  if (is.null(v)) numeric(0) else as.numeric(v)
}


tornado_plot <- function(bigwig, 
             features,
             bin_size = 40,
             method = "mean",
             drop_empty_rows = TRUE,
             order_rows = TRUE,
             top_percentile = 0.98, 
             bottom_percentile = 0.02, 
             cols = rev(c("darkblue", "royalblue", "lightblue", "white", "lightyellow", "orange", "red", "darkred")),
             na_col = "black",
             nthreads = detectCores(),
             use_raster = TRUE,          # smoother & faster
             raster_quality = 1
  ){
  if(class(features)=="GRanges"){
    features = list(as.character(features@seqnames), as.integer(features@ranges@start), as.integer(features@ranges@start+features@ranges@width -1), as.character(features@strand), features$name)
    out <- read_bigwig_using_gr(features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
    
  } else {
    if(!file.exists(features)){stop("feature argument must be a Granges object or a path to a valid bed file")}
    out <- read_bigwig_using_bed(bed_path = features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
  }
  
  
  m <- as_matrix(out)
  if(order_rows){
    ord <- order(rowMeans(m, na.rm = TRUE), decreasing = TRUE)
    m <- m[ord, , drop=FALSE]
  }
  if(drop_empty_rows){
    keep <- rowSums(is.finite(m) & m != 0) > 0
    m <- m[keep, , drop=FALSE]
  }

  zmin  <- as.numeric(quantile(m, bottom_percentile, na.rm = TRUE)) 
  zmax  <- as.numeric(quantile(m, top_percentile, na.rm = TRUE))  
  m_cap <- pmin(pmax(m, zmin), zmax)

  ComplexHeatmap::Heatmap(
    m_cap,
    name = "signal", 
    col = cols,
    na_col = na_col, 
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = use_raster,
    raster_quality = raster_quality
  )
}


compute_matrix <- function(bigwig, 
             features,
             bin_size = 40,
             method = "mean",
             drop_empty_rows = TRUE,
             order_rows = TRUE,
             cap = TRUE,
             top_percentile = 0.98, 
             bottom_percentile = 0.02, 
             nthreads = detectCores()
  ){
  if(class(features)=="GRanges"){
    features = list(as.character(features@seqnames), as.integer(features@ranges@start), as.integer(features@ranges@start+features@ranges@width -1), as.character(features@strand), features$name)
    out <- read_bigwig_using_gr(features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
    
  } else {
    if(!file.exists(features)){stop("feature argument must be a Granges object or a path to a valid bed file")}
    out <- read_bigwig_using_bed(bed_path = features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
  }
  
  
  m <- as_matrix(out)
  if(order_rows){
    ord <- order(rowMeans(m, na.rm = TRUE), decreasing = TRUE)
    m <- m[ord, , drop=FALSE]
  }
  if(drop_empty_rows){
    keep <- rowSums(is.finite(m) & m != 0) > 0
    m <- m[keep, , drop=FALSE]
  }

  if(cap){
    zmin  <- as.numeric(quantile(m, bottom_percentile, na.rm = TRUE)) 
    zmax  <- as.numeric(quantile(m, top_percentile, na.rm = TRUE))  
    m_cap <- pmin(pmax(m, zmin), zmax)
    return(m_cap)
  } else {
    return(m)
  }
}




read_bed_as_granges <- function(bed,
                                keep_std_chroms = TRUE,
                                style = c("UCSC", "NCBI"),
                                genome = NULL) {
  style <- match.arg(style)

  if (!requireNamespace("rtracklayer", quietly = TRUE)) {
    stop("Please install rtracklayer: BiocManager::install('rtracklayer')")
  }
  if (!requireNamespace("GenomeInfoDb", quietly = TRUE)) {
    stop("Please install GenomeInfoDb: BiocManager::install('GenomeInfoDb')")
  }
  if (!requireNamespace("data.table", quietly = TRUE)) {
    stop("Please install data.table")
  }

  # ---- Try import() first
  gr <- tryCatch({
    if (grepl("\\.gz$", bed, ignore.case = TRUE)) {
      con <- gzfile(bed, "rt")
      gr <- rtracklayer::import(con, format = "BED")
      close(con)
      gr
    } else {
      rtracklayer::import(bed, format = "BED")
    }
  }, error = function(e) {
    message("rtracklayer::import failed (", conditionMessage(e), "). Falling back to data.table::fread().")
    NULL
  })

  # ---- Fallback to fread if needed
  if (is.null(gr)) {
    # Peek at first line to detect header
    first_line <- if (grepl("\\.gz$", bed, ignore.case = TRUE)) {
      readLines(gzfile(bed), n = 1)
    } else {
      readLines(bed, n = 1)
    }

    skip <- 0
    header <- FALSE
    if (grepl("^track|^browser", first_line, ignore.case = TRUE)) {
      skip <- 1
    } else if (!grepl("^[^[:space:]]+[[:space:]]+[0-9]", first_line)) {
      # Not "chrom start", so assume it's a header row
      header <- TRUE
    }

    dt <- data.table::fread(bed, header = header, skip = skip)

    if (ncol(dt) < 3) stop("BED must have at least 3 columns")

    # Standard BED column names
    colnames(dt)[1:3] <- c("chrom", "start", "end")

    # BED is 0-based, half-open
    dt[, start := start + 1L]

    gr <- GenomicRanges::GRanges(
      seqnames = dt$chrom,
      ranges   = IRanges::IRanges(start = dt$start, end = dt$end),
      strand   = if ("strand" %in% colnames(dt)) Rle(dt$strand) else Rle("*")
    )

    if ("name" %in% colnames(dt)) {
      mcols(gr)$name <- dt$name
    } else if ("V4" %in% colnames(dt)) {
      mcols(gr)$name <- dt$V4
    }
  }

  # ---- Normalize seqlevel style
  GenomeInfoDb::seqlevelsStyle(gr) <- style

  if (keep_std_chroms) {
    std <- GenomeInfoDb::standardChromosomes(gr)
    if (length(std)) {
      gr <- gr[as.character(GenomeInfoDb::seqnames(gr)) %in% std]
    }
  }

  GenomeInfoDb::seqlevels(gr) <- GenomeInfoDb::seqlevelsInUse(gr)

  if (!"name" %in% colnames(mcols(gr)) && ncol(mcols(gr)) > 0) {
    mcols(gr)$name <- mcols(gr)[[1]]
  }

  if (!is.null(genome)) {
    GenomeInfoDb::genome(gr) <- genome
  }

  gr
}
```

```{r}
library(GenomicRanges)
nn<-read_json_file("/Volumes/furlan_s/sfurlan/250302_leuklong/pbWGS/LL4_SAdd/pacbiowdlR/outputs.json")
bed <- "hg38_gene_promoters_2kb_up_2kb_down.bed"
bwm <- nn$humanwgs_singleton.cpg_combined_bw
bw <- "/Volumes/furlan_s/sfurlan/250302_leuklong/fibertools/FIRE/results/LL4_SAdd/trackHub-v0.1.1/bw/all.fire.coverage.bw"
#bed <- "peaks.bed"

am <- compute_matrix(bw, gr)
mm <- compute_matrix(bwm, gr)

dim(am)
dim(mm)

amf <- am[intersect(rownames(am), rownames(mm)),]
mmf <- mm[intersect(rownames(am), rownames(mm)),]

mmf <- mmf[rownames(amf),]

ComplexHeatmap::Heatmap(
    amf,
    name = "signal", 
    col = rev(c("darkblue", "royalblue", "lightblue", "white", "lightyellow", "orange", "red", "darkred")),
    na_col = "black",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = T,
    raster_quality = 1
  )


ComplexHeatmap::Heatmap(
    mmf,
    name = "signal", 
    col = rev(c("darkblue", "royalblue", "lightblue", "white", "lightyellow", "orange", "red", "darkred")),
    na_col = "black",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = T,
    raster_quality = 1
  )


```


