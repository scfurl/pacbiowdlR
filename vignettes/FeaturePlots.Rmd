---
title: "Exploring Methylation and Accessibility Calls"
author: "Scott Furlan"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
params:
  EVAL: !r identical(Sys.getenv("NOT_CRAN"), "true")
vignette: >
  %\VignetteIndexEntry{Exploring Methylation and Accessibility Calls}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
alias: dna_fusions
editor_options: 
  chunk_output_type: console
---

```{r, child="children/SETTINGS-knitr_fusions.txt"}
```


```{r}
library(rtracklayer)
library(parallel)
gff <- "/Users/sfurlan/refs/GRCh38/gencode.v49.annotation.gff3"
data <- import(gff)
can <- pbmcapply::pbmclapply(data$tag, function(vec) grep("Ensembl_canonical", vec), mc.cores = detectCores())
hits <- which(sapply(can, function(item) length(item)>0))
canonical <- data[hits,]
tss <- canonical[canonical$type=="start_codon",]
start(tss) <- start(tss) - 2000
end(tss) <- end(tss) + 2000
tss$name <- tss$gene_name

```




```{r}
library(pacbiowdlR)
###REQUIRED FUNCTIONS


# make a matrix (regions x bins). If lengths differ, pad with NA (left-align).
as_matrix <- function(out) {
  lens <- vapply(out, function(r) length(cov_vec(r)), integer(1))
  if (length(unique(lens)) != 1L) {
    L <- max(lens)
    mat <- t(vapply(out, function(r) {
      v <- cov_vec(r)
      c(v, rep(NA_real_, L - length(v)))
    }, numeric(L)))
  } else {
    L <- lens[1]
    mat <- t(vapply(out, function(r) as.numeric(r$coverage), numeric(L)))
  }
  rownames(mat) <- vapply(out, function(r) if (!is.null(r$name)) r$name else "", character(1))
  mat
}

# pull coverage vector; gracefully handle NULL/NA
cov_vec <- function(r) {
  v <- r$coverage
  if (is.null(v)) numeric(0) else as.numeric(v)
}


tornado_plot <- function(bigwig, 
             features,
             bin_size = 40,
             method = "mean",
             drop_empty_rows = TRUE,
             order_rows = TRUE,
             top_percentile = 0.98, 
             bottom_percentile = 0.02, 
             cols = rev(c("darkblue", "royalblue", "lightblue", "white", "lightyellow", "orange", "red", "darkred")),
             na_col = "black",
             nthreads = detectCores(),
             use_raster = TRUE,          # smoother & faster
             raster_quality = 1
  ){
  if(class(features)=="GRanges"){
    features = list(as.character(features@seqnames), as.integer(features@ranges@start), as.integer(features@ranges@start+features@ranges@width -1), as.character(features@strand), features$name)
    out <- read_bigwig_using_gr(features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
    
  } else {
    if(!file.exists(features)){stop("feature argument must be a Granges object or a path to a valid bed file")}
    out <- read_bigwig_using_bed(bed_path = features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
  }
  
  
  m <- as_matrix(out)
  if(order_rows){
    ord <- order(rowMeans(m, na.rm = TRUE), decreasing = TRUE)
    m <- m[ord, , drop=FALSE]
  }
  if(drop_empty_rows){
    keep <- rowSums(is.finite(m) & m != 0) > 0
    m <- m[keep, , drop=FALSE]
  }

  zmin  <- as.numeric(quantile(m, bottom_percentile, na.rm = TRUE)) 
  zmax  <- as.numeric(quantile(m, top_percentile, na.rm = TRUE))  
  m_cap <- pmin(pmax(m, zmin), zmax)

  ComplexHeatmap::Heatmap(
    m_cap,
    name = "signal", 
    col = cols,
    na_col = na_col, 
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = use_raster,
    raster_quality = raster_quality
  )
}


compute_matrix <- function(bigwig, 
             features,
             bin_size = 40,
             method = "mean",
             drop_empty_rows = TRUE,
             order_rows = TRUE,
             cap = TRUE,
             top_percentile = 0.98, 
             bottom_percentile = 0.02, 
             nthreads = detectCores()
  ){
  if(class(features)=="GRanges"){
    features = list(as.character(features@seqnames), as.integer(features@ranges@start), as.integer(features@ranges@start+features@ranges@width -1), as.character(features@strand), features$name)
    out <- read_bigwig_using_gr(features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
    
  } else {
    if(!file.exists(features)){stop("feature argument must be a Granges object or a path to a valid bed file")}
    out <- read_bigwig_using_bed(bed_path = features, bw_path = bigwig, bin_size = bin_size, method = method, nthreads = nthreads)
  }
  
  
  m <- as_matrix(out)
  if(order_rows){
    ord <- order(rowMeans(m, na.rm = TRUE), decreasing = TRUE)
    m <- m[ord, , drop=FALSE]
  }
  if(drop_empty_rows){
    keep <- rowSums(is.finite(m) & m != 0) > 0
    m <- m[keep, , drop=FALSE]
  }

  if(cap){
    zmin  <- as.numeric(quantile(m, bottom_percentile, na.rm = TRUE)) 
    zmax  <- as.numeric(quantile(m, top_percentile, na.rm = TRUE))  
    m_cap <- pmin(pmax(m, zmin), zmax)
    return(m_cap)
  } else {
    return(m)
  }
}




read_bed_as_granges <- function(bed,
                                keep_std_chroms = TRUE,
                                style = c("UCSC", "NCBI"),
                                genome = NULL) {
  style <- match.arg(style)

  if (!requireNamespace("rtracklayer", quietly = TRUE)) {
    stop("Please install rtracklayer: BiocManager::install('rtracklayer')")
  }
  if (!requireNamespace("GenomeInfoDb", quietly = TRUE)) {
    stop("Please install GenomeInfoDb: BiocManager::install('GenomeInfoDb')")
  }
  if (!requireNamespace("data.table", quietly = TRUE)) {
    stop("Please install data.table")
  }

  # ---- Try import() first
  gr <- tryCatch({
    if (grepl("\\.gz$", bed, ignore.case = TRUE)) {
      con <- gzfile(bed, "rt")
      gr <- rtracklayer::import(con, format = "BED")
      close(con)
      gr
    } else {
      rtracklayer::import(bed, format = "BED")
    }
  }, error = function(e) {
    message("rtracklayer::import failed (", conditionMessage(e), "). Falling back to data.table::fread().")
    NULL
  })

  # ---- Fallback to fread if needed
  if (is.null(gr)) {
    # Peek at first line to detect header
    first_line <- if (grepl("\\.gz$", bed, ignore.case = TRUE)) {
      readLines(gzfile(bed), n = 1)
    } else {
      readLines(bed, n = 1)
    }

    skip <- 0
    header <- FALSE
    if (grepl("^track|^browser", first_line, ignore.case = TRUE)) {
      skip <- 1
    } else if (!grepl("^[^[:space:]]+[[:space:]]+[0-9]", first_line)) {
      # Not "chrom start", so assume it's a header row
      header <- TRUE
    }

    dt <- data.table::fread(bed, header = header, skip = skip)

    if (ncol(dt) < 3) stop("BED must have at least 3 columns")

    # Standard BED column names
    colnames(dt)[1:3] <- c("chrom", "start", "end")

    # BED is 0-based, half-open
    dt[, start := start + 1L]

    gr <- GenomicRanges::GRanges(
      seqnames = dt$chrom,
      ranges   = IRanges::IRanges(start = dt$start, end = dt$end),
      strand   = if ("strand" %in% colnames(dt)) Rle(dt$strand) else Rle("*")
    )

    if ("name" %in% colnames(dt)) {
      mcols(gr)$name <- dt$name
    } else if ("V4" %in% colnames(dt)) {
      mcols(gr)$name <- dt$V4
    }
  }

  # ---- Normalize seqlevel style
  GenomeInfoDb::seqlevelsStyle(gr) <- style

  if (keep_std_chroms) {
    std <- GenomeInfoDb::standardChromosomes(gr)
    if (length(std)) {
      gr <- gr[as.character(GenomeInfoDb::seqnames(gr)) %in% std]
    }
  }

  GenomeInfoDb::seqlevels(gr) <- GenomeInfoDb::seqlevelsInUse(gr)

  if (!"name" %in% colnames(mcols(gr)) && ncol(mcols(gr)) > 0) {
    mcols(gr)$name <- mcols(gr)[[1]]
  }

  if (!is.null(genome)) {
    GenomeInfoDb::genome(gr) <- genome
  }

  gr
}
```

```{r}
library(GenomicRanges)
library(ComplexHeatmap)
nn<-read_json_file("/Volumes/furlan_s/sfurlan/250302_leuklong/pbWGS/LL4_SAdd/pacbiowdlR/outputs.json")
bed <- "hg38_gene_promoters_2kb_up_2kb_down.bed"
#bwm <- nn$humanwgs_singleton.cpg_combined_bw
bwa <- "/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchCancerCenter/Furlan_Lab_2025 - General/experiments/Leuklong/temp/NN_AML/all.fire.coverage.bw"
bwm <- "/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchCancerCenter/Furlan_Lab_2025 - General/experiments/Leuklong/temp/NN_AML/LL4_SAdd.GRCh38.cpg_pileup.combined.bw"
#bed <- "peaks.bed"

am <- compute_matrix(bwa, tss)
mm <- compute_matrix(bwm, tss)

dim(am)
dim(mm)

amf <- am[intersect(rownames(am), rownames(mm)),]
mmf <- mm[intersect(rownames(am), rownames(mm)),]

mmf <- mmf[rownames(amf),]

top <- data.frame(signal=colMeans(amf, na.rm = T), position=1:ncol(amf))


ComplexHeatmap::Heatmap(
    amf,
    name = "signal", 
    col = rev(c("darkblue", "blue", "royalblue", "lightblue",  "lightyellow", "yellow", "orange", "red", "darkred")),
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = T,
    raster_quality = 1,
    top_annotation = columnAnnotation(signal=anno_lines(colMeans(amf, na.rm = T), gp = gpar(col = "blue")))
  )


ComplexHeatmap::Heatmap(
    mmf,
    name = "signal", 
    col = rev(c("darkblue", "royalblue", "lightblue", "white","lightyellow", "pink")),
    na_col = "black",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = T,
    raster_quality = 1,
    top_annotation = columnAnnotation(signal=anno_lines(colMeans(mmf, na.rm = T)))
  )


```

```{r}
library(JASPAR2022)
library(TFBSTools)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg38) # or your genome
library(motifmatchr)                 # fast scanning to GRanges
library(GenomicRanges)

# 1) Get the CTCF motif
pfm_list <- getMatrixSet(
  JASPAR2022, 
  opts = list(name = "CTCF", species="Homo sapiens")
)
pfm <- pfm_list[[1]]                 # choose MA0139.* you prefer

# 2) Convert to PWM and scan
pwm <- toPWM(pfm, type="log2probratio", pseudocounts=0.8)
# Build tiling windows or scan chromosome by chromosome:
seqs <- getSeq(BSgenome.Hsapiens.UCSC.hg38) # all chromosomes
hits <- matchMotifs(pwm, seqs, out = "positions", p.cutoff = 1e-4)
hits <- hits[[1]][names(seqs) %in% paste0("chr", c(1:22, "X", "Y", "M"))]
seqs <- names(seqs)[names(seqs) %in% paste0("chr", c(1:22, "X", "Y", "M"))]
# 3) GRanges of motif hits
gr_list <- lapply(seq_along(hits), function(n) {
  ir <- hits[[n]]
  st <- mcols(ir)$strand
  sc <- mcols(ir)$score
  mcols(ir)$strand <- NULL
  mcols(ir)$score  <- NULL
  g <- GRanges(seqnames = seqs[n], ranges = ir, strand = st)
  mcols(g)$score <- sc
  g
})
ctcf_gr <- do.call(c, gr_list)
ctcf_gr$name <- paste0("ctcf", 1:length(ctcf_gr))


am <- compute_matrix(bwa, ctcf_gr, bin_size = 1)
mm <- compute_matrix(bwm, ctcf_gr, bin_size = 1)

dim(am)
dim(mm)

amf <- am[intersect(rownames(am), rownames(mm)),]
mmf <- mm[intersect(rownames(am), rownames(mm)),]

mmf <- mmf[rownames(amf),]


ComplexHeatmap::Heatmap(
    amf,
    name = "signal", 
    col = rev(c("darkblue", "blue", "royalblue", "lightblue",  "lightyellow", "yellow", "orange", "red", "darkred")),
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = T,
    raster_quality = 1,
    top_annotation = columnAnnotation(signal=anno_lines(colMeans(amf, na.rm = T), gp = gpar(col = "blue")))
  )


ComplexHeatmap::Heatmap(
    mmf,
    name = "signal", 
    col = rev(c("darkblue", "royalblue", "lightblue", "white","lightyellow", "pink")),
    na_col = "black",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = F,
    raster_quality = 1,
    top_annotation = columnAnnotation(signal=anno_lines(colMeans(mmf, na.rm = T)))
  )


```


```{r}
library(rtracklayer)
path = "data/hg19ToHg38.over.chain"
ch = import.chain(path)
d <- openxlsx::read.xlsx("/Users/sfurlan/develop/pacbiowdlR/data/SuppTables.xlsx", sheet = "SuppTable2- CTCF binding sites")
d[,8] <- gsub("\\.", "*", d[,8])
ctcf <- GRanges(seqnames = d[,2], ranges = IRanges(start = d[,5], end = d[,6]), strand = d[,8])
ctcf_hg38 <-  liftOver(ctcf, ch)
ctcf_2kb <- unlist(resize(ctcf_hg38, width = 2000, fix = "center"))
ctcf_2kb$name <- paste0("ctcf", 1:length(ctcf_2kb))


am <- compute_matrix(bwa, ctcf_2kb, bin_size = 2)
mm <- compute_matrix(bwm, ctcf_2kb, bin_size = 20)

dim(am)
dim(mm)

amf <- am[intersect(rownames(am), rownames(mm)),]
mmf <- mm[intersect(rownames(am), rownames(mm)),]

mmf <- mmf[rownames(amf),]

prot_ma <- t(apply(1-amf, 1, \(x) zoo::rollmean(x, 20/2, fill=NA, align="center"))) # 20 bp with bin_size=2

ComplexHeatmap::Heatmap(
    prot_ma,
    name = "signal", 
    col = rev(c("darkblue", "blue", "royalblue", "lightblue",  "lightyellow", "yellow", "orange", "red", "darkred")),
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = T,
    raster_quality = 1,
    top_annotation = columnAnnotation(signal=anno_lines(colMeans(prot_ma, na.rm = T), gp = gpar(col = "blue")))
  )


mmf <- mm
ComplexHeatmap::Heatmap(
    mmf,
    name = "signal", 
    col = rev(c("darkblue", "royalblue", "lightblue", "red")),
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    use_raster = F,
    raster_quality = 1,
    top_annotation = columnAnnotation(signal=anno_lines(colMeans(mmf, na.rm = T)))
  )
```

